/*Двумерные массивы

Первое и главное — как задаются двумерные массивы. По аналогии с одномерными массивами мы 
указываем тип данных (например, string), в квадратных скобках ставим запятую как показатель того, 
что у нас будет две размерности: первая — строки, вторая — столбцы. Потом даём массиву название 
(например, table). После этого пишем new string и указываем, какое количество строчек и столбцов 
нам нужно. 
*/

// string[,] table = new string[2,3]


// string[,] table = new string[2,5];
// // String.Empty
// // table [0,0] table [0,1] table [0,2] table [0,4]
// // table [1,0] table [1,1] table [1,2] table [1,4]
// table[1, 2] = "слово";
// for (int rows = 0; rows < 2; rows++)
// {
//      for (int columns = 0; columns < 5; columns++)
//      {
//          Console.WriteLine($"−{table[rows, columns]}−");
//      }
// }

// int[,] matrix = new int[3, 4];
// for (int i = 0; i < 3; i++)
// {
//     for (int j = 0; j < 4; j++)
//     {
//         Console.Write($"{matrix[i, j]} ");
//     }
// Console.WriteLine();
// }

/*Для тройки( строк и столбцов) указываем имя массива и новый 
функционал GetLength(0). 0 в качестве аргумента означает количество строк. Аналогично и для 
четвёрки: пишем имя массива, точку и GetLength(1).
*/
// int[,] matrix = new int[3, 4];
// for (int i = 0; i < matrix.GetLength(0); i++)
// {
//     for (int j = 0; j < matrix.GetLength(1); j++)
//     {
//     Console.Write($"{matrix[i, j]} ");
//     }
//  Console.WriteLine();   
// }

// Заполнение матрицы случайными числами

// void PrintArray(int[,] matr)
// {
//     for (int i = 0; i < matr.GetLength(0); i++)
//     {
//         for (int j = 0; j < matr.GetLength(1); j++)
//         {
//             Console.Write($"{matr[i, j]} ");
//         }
//     Console.WriteLine();
//     }
// }


// int[,] matrix = new int[3, 4];
// PrintArray(matrix);

/*Теперь опишем дополнительный метод, который будет заполнять нашу матрицу случайными числами. 
Здесь всё почти так же, как с одномерными массивами. Для i указываем matr.GetLength(0), для J —
matr.GetLength(1). Затем обращаемся к конкретному элементу на позиции «итый-житый» и пишем 
через использование генератора псевдослучайных чисел. Возьмём полуинтервал от 1 до 10. 
Напоминаю, из-за круглых скобок может показаться, что это интервал (как в математике), но у нас 
получается именно полуинтервал. 
Проверим работоспособность нашего метода. Сначала инициализируемся, убедимся, что у нас нули. 
Затем сделаем FillArray, в качестве аргумента передадим наш массив и снова распечатаем. А чтобы 
отделить нули от чисел, перед финальной распечаткой добавим Console.WriteLine().
*/

// void PrintArray(int[,] matr)
// {
//     for (int i = 0; i < matr.GetLength(0); i++)
//     {  
//         for (int j = 0; j < matr.GetLength(1); j++)
//         {
//             Console.Write($"{matr[i, j]} ");
//         }

//     Console.WriteLine();
//     }
// }
// void FillArray(int[,] matr)
// {
//     for (int i = 0; i < matr.GetLength(0); i++)
//     {
//         for (int j = 0; j < matr.GetLength(1); j++)
//         {
//             matr[i,j] = new Random().Next(1,10);//[1; 10)
//         }
//     }
// }
// int[,] matrix = new int[3, 4];
// PrintArray(matrix);
// FillArray(matrix);
// Console.WriteLine();
// PrintArray(matrix);

/*Закрашивание области

Мы попробовали использовать двумерные массивы. Теперь важно запомнить, как и что описывается. 
Обязательны:
● тип данных,
● квадратные скобки с запятой внутри,
● именование массива или идентификатор массива, 
● оператор присваивания,
● обязательное условие new,
● тип данных,
● количество строк и столбцов в квадратных скобках. 
Имя массива.GetLength(0) возвращает количество строк в вашем массиве. Имя массива.GetLength(1) 
— количество столбцов. 
*/

/*Где это можно использовать? Попробуем взять классическую задачу, которую вы решали в модуле 
«Математика и информатика», где мы разбирали простые двухцветные картинки. Идея: обычная 
прямоугольная таблица чисел, для которых вы можете определить в качестве 0 незакрашенный 
пиксель, а в качестве 1 — закрашенный. Это абсолютно прямая отсылка к двумерным числовым 
массивам.
*/

/*Давайте формально опишем шаги влево, вверх, вправо и вниз. Если мы находимся в текущей точке с 
координатами x, y (в данном случае x — позиция строчки, а y — столбца), движение будет выглядеть 
таким образом: 


         x-1, y
x, y-1    x, y    x, y+1
         x+1, y
Можно двигаться и по диагонали, но тогда придётся проверять дополнительные условия. 
x-1, y-1    x-1, y    x-1, y+1
x, y-1       x, y     x, y+1
x+1, y-1    x+1, y    x+1, y+1
Далее мы должны определить порядок действий. Я договариваюсь ходить сначала вверх, потом 
влево, вниз и вправо. Всё ровно так, как на примере с закрашиванием пикселей

Теперь давайте попробуем написать код, который позволит нам взять картинку и закрасить область 
внутри контура. 

В качестве аргумента вместо matr укажем условный image. Дальше всё то же самое, но в момент 
вывода проделаем хитрую операцию: будем проверять, если текущий элемент image[i,j] совпадает с 0, 
13
будем искусственно печатать пробел. В противном случае мы можем распечатать плюс. PrintImage в 
качестве аргумента передаём массив, который содержит в себе картинку. 
*/
// int[,] pic = new int[,];
// { 
// {0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0 }; 
// {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
// {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
// {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
// {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
// {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
// {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
// {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
// {0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
// {0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 }, 
// {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 }, 
// {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 }, 
// {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0 }, 
// {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 }, 
// {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 }, 
// {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0 }, 
// {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 }, 
// {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 }, 
// {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 }, 
// {0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 }, 
// {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }, 
// {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 }, 
// {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
// };

// void PrintImage(int[,] image)
// {
//     for (int i = 0; i < image.GetLength(0); i++)
//     {
//         for (int j = 0; j < image.GetLength(1); j++)
//         {
//             if(image[i,j] == 0) Console.Write($" ");
//             else Console.Write($"+");
//         }
//         Console.WriteLine();
//     }
// }
// PrintImage(pic);

/*Видим палец вверх
Дальше предлагаю описать метод, который будет закрашивать картинку. По аналогии назовём его 
FillImage. А в качестве аргумента я укажу позицию строки и пикселя, с которого мы должны будем 
начать закраску. Дальше я проверяю условие: если текущий пиксель (pic) с указанной позицией (row, 
col) равен нулю (то есть не закрашен), я буду его красить единичкой. А дальше вызову FillImage. И 
здесь мы определяем правило — что за чем идёт. Сначала поднимаемся на строчку выше (row-1, col), 
потом идём влево (row, col-1), потом вниз (row+1, col), потом вправо (row, col+1). 
*/

// void PrintImage(int[,] image)
// {
//     for (int i = 0; i < image.GetLength(0); i++)
//     {
//         for (int j = 0; j < image.GetLength(1); j++)
//         {
//             if(image[i,j] == 0) Console.Write($" ");
//             else Console.Write($"+");
//         }
//         Console.WriteLine();
//     }
// }
// void FillImage(int row, int col)
// {
//     if (pic[row, col] == 0) 
//     {
//         pic[row, col] = 1;
//         FillImage(row - 1, col);
//         FillImage(row, col - 1);
//         FillImage(row + 1, col);
//         FillImage(row, col + 1);
//     }
// }
// PrintImage(pic);
// FillImage(13, 13);
// PrintImage(pic);


/*Рекурсия
Что такое рекурсия? Это функция, которая вызывает сама себя. 
*/

/*Вычисление факториала
Что такое факториал? В математике под факториалом понимают произведения чисел от 1 до 
заданного и обозначают его восклицательным знаком — «!». Пример факториала: 5! = 5 * 4 * 3 * 2 * 1.
*/
// int Factorial(int n)
// {
//     // 1! = 1
//     // 0! = 1
//     if(n == 1) return 1;
//     else return n * Factorial(n-1);
// }
// Console.WriteLine(Factorial(3)); // 1 * 2 * 3 = 6

/*Казалось бы, задачу решили. Но есть проблема: когда мы будем вычислять большие числа (допустим, 
40!), в какой-то момент начнём получать отрицательные числа, чего быть не должно.
Это связано с переполнением типа.
*/
// int Factorial(int n)
// {
//     // 1! = 1
//     // 0! = 1
//     if(n == 1) return 1;
//     else return n * Factorial(n-1);
// }
// for (int i = 1; i < 40; i++)
// {
//  Console.WriteLine($"{i}! = {Factorial(i)}");
// }
/*То есть число 17! попросту не вмещается в тип данных integer, поэтому появляется первая ваша задача, 
связанная с переполнением. Как её решать? Разными способами. Есть тип данных, который такие числа 
ещё способен переваривать, — double
*/
// double Factorial(int n)
// {
//     // 1! = 1
//     // 0! = 1
//     if(n == 1) return 1;
//     else return n * Factorial(n-1);
// }
// for (int i = 1; i < 40; i++)
// {
//  Console.WriteLine($"{i}! = {Factorial(i)}");
// }

/*Вычисление чисел Фибоначчи

Для начала укажем определение. Первое число можно указать как f(1)=1, дальше — f(2)=1. Для всех 
следующих — то есть, f(n) — мы определяем числа Фибоначчи как f(n-1) + f(n-2). Давайте напишем этот 
код
*/


// int Fibonacci(int n)
// {
//  if(n == 1 || n == 2) return 1;
//  else return Fibonacci(n-1) + Fibonacci(n-2);
// }
// for (int i = 1; i < 10; i++)
// {
//  Console.WriteLine(Fibonacci(i));
// }
// Получаются те самые числа Фибоначчи — каждое равно сумме двух предыдущих. 

/*Тетрис
От себя отмечу, что весь функционал и весь инструментарий, чтобы реализовать эту игру, у вас есть. В 
чём основная затея? Обычное поле тетриса — это двумерный массив. В нём есть 0 (свободные клетки) и 
1 (клетки, на данном этапе занятые какой-то фигурой). Движение фигуры — смещение 0 и 1 
относительно друг друга. 
Прямоугольная таблица чисел — это матрица. А матрицы мы можем поворачивать. Соответственно, 
поворот фигуры — это поворот матрицы. Обязательно дожидаемся семинаров и разбираем это более 
детально.
*/ 